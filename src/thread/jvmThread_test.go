/*
 * Jacobin VM - A Java virtual machine
 * Copyright (c) 2022-3 by the Jacobin authors. All rights reserved.
 * Licensed under Mozilla Public License 2.0 (MPL 2.0)
 */

package thread

import (
	"fmt"
	"jacobin/globals"
	"sync"
	"testing"
	"time"
)

func TestCreateThread(t *testing.T) {
	et := CreateThread()
	if et.ID < 1 ||
		// et.PC != 0 ||
		et.Trace != false {
		t.Error("Invalid thread generated by CreateThread()")
	}
}

func TestAddThreadToTable(t *testing.T) {
	globals.InitGlobals("test")
	gl := globals.GetGlobalRef()
	tbl := gl.Threads
	// tbl.ThreadsList = list.New()
	// retVal := 0

	for i := 0; i < 10; i++ {
		th := CreateThread()
		// retVal = AddThreadToTable(&th, &tbl)
		th.AddThreadToTable(gl)
	}

	// tblLen := tbl.ThreadsList.Len()
	tblLen := len(tbl)
	if tblLen != 10 {
		t.Errorf("Expected thread table to have 10 elements; got %d",
			tblLen)
	}

	if gl.ThreadNumber != 10 {
		t.Errorf("Expected last inserted thread to be 10; got %d", gl.ThreadNumber)
	}
}

// This tests validates that the use of the mutex on addition of
// threads to the thread table works correctly. It starts four
// goroutines that each add 100 threads to the same table. It uses
// a wait group to wait for the four routines to finish, then gets
// the size of the table and validates that it = 400.
func TestAddingMultipleSimultaneousThreads(t *testing.T) {
	globals.InitGlobals("test")
	gl := globals.GetGlobalRef()
	tbl := gl.Threads

	wg := sync.WaitGroup{}

	wg.Add(1)
	go add100threads(&wg, gl)

	wg.Add(1)
	go add100threads(&wg, gl)

	wg.Add(1)
	go add100threads(&wg, gl)

	wg.Add(1)
	go add100threads(&wg, gl)

	time.Sleep(1 * time.Millisecond) // make sure all is complete
	wg.Wait()                        // wait for the goroutines to all finish
	size := len(tbl)
	if size != 400 {
		t.Errorf("Expecting thread table size of 400, got %d", size)
		fmt.Printf("Thread counter: %d\n", gl.ThreadNumber)
	}

}

// Called by the goroutines in TestAddingMultipleSimultaneousThreads()
// to add 100 threads to the thread table and decrements the wait
// group by 1 when it's done. Note that the wait group is initialized
// prior to the goroutine being called, as prescribed by the go docs.
func add100threads(wgrp *sync.WaitGroup, glob *globals.Globals) {
	// create and add 100 threads
	for i := 0; i < 100; i++ {
		th := CreateThread()
		th.AddThreadToTable(glob)
	}
	time.Sleep(1 * time.Millisecond) // make sure all is complete
	wgrp.Done()                      // decrements the wait group by 1.
}
